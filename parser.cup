/*
   Simple +/-/* expression language; 
   parser evaluates constant expressions on the fly
*/

package cup.example;

import java_cup.runtime.*;
import cup.example.Lexer;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;

parser code {:
  protected Lexer lexer;
  /* Initiate array values to 0 */
  Double MEM[] = new Double[100];
  {
    for (int i = 0; i<MEM.length; i++){
      MEM[i] = 0.0;
    }
  }
:};

/* define how to connect to the scanner! */
init with {:
  ComplexSymbolFactory f = new ComplexSymbolFactory();
  symbolFactory = f;
  File file = new File("input.txt");
  FileInputStream fis = null;
  try {
    fis = new FileInputStream(file);
  } catch (IOException e) {
    e.printStackTrace();
  } 
  lexer = new Lexer(f,fis);

:};
scan with {: return lexer.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal           SEMI, PLUS, MINUS, TIMES, DIVISION, UMINUS, LPAREN, RPAREN,
LOG, EXP, LN, SIN, COS, EQUAL, PLUSPLUS, MINUSMINUS, TRUE, FALSE, ASIGNATION,
MORETHAN, LESSTHAN, ISEQUAL, AND, NOT, OR, FINMIENTRAS,
VECTOR, MIENTRAS, SI, ENTRADA, ENTONCES, SINO, FINSI;
terminal Double    NUMBER;        // our scanner provides numbers as doubles
terminal Integer   ARRAYMEM;
terminal Character CHAR;
terminal String IDENTIFIER, ENTERO, REAL, BOOLEANO, CARACTER;

/* Non terminals */
non terminal  sentencia, sent_decl, sent_uso, sent_flujo, 
asignacion, condicional, bucle;
non terminal Double exprNum, term, factor;      // used to store evaluated subexpressions
non terminal Boolean exprBool;
non terminal String tipo, decl_variable;

/* Precedences */
precedence left AND, OR;  
precedence nonassoc MORETHAN, LESSTHAN, ISEQUAL; 
precedence left PLUS, MINUS;  
precedence left TIMES, DIVISION;
precedence left UMINUS;


/* The grammar rules */			
sentencia  ::=  sent_decl:e                 {:  			  :}
            	| sent_uso:e                 {:  			  :}
            	| sent_flujo:e                 {:  			  :}
            	;
sent_decl  ::= decl_variable  			 {:  	:}
				;
decl_variable ::= tipo:t IDENTIFIER:i ASIGNATION exprNum:e SEMI    {: System.out.println(t + " " + i + " " + ":=" + " " + e ); 	:}
				    |tipo IDENTIFIER ASIGNATION exprBool SEMI    {:  	:} 
					|tipo:t IDENTIFIER:i SEMI 			{:    System.out.println(t + " " + i );	:}
				;
tipo       ::=  ENTERO								        {: RESULT =  "ENTERO";	:}
					| REAL    							{: RESULT =  "REAL"; :}
					| BOOLEANO							{: RESULT =  "BOOLEANO"; 	:}
					| CARACTER  							{: RESULT =  "CARACTER"; 	:}
				;	
exprNum      ::= 	exprNum:e PLUS   exprNum:e1          {: RESULT = e+e1;        			      :}
	            | exprNum:e MINUS exprNum: e1          {: RESULT = e-e1;  				      :}
	            | exprNum:e TIMES exprNum: e1          {: RESULT = e*e1;  				      :} 
	            | exprNum:e DIVISION exprNum: e1          {: RESULT = e/e1;  				      :}
	            %prec UMINUS
	            | LPAREN exprNum:e RPAREN          {: RESULT = e;                         :}
				| NUMBER: n				   {: RESULT = n;                         :}
	 	 	 	;
	 	 	 	
exprBool  ::=   exprNum:e LESSTHAN exprNum: e1          {: if ( e < e1) RESULT = true; 										
																else RESULT = false;		 	  :} 
	            | exprNum:e MORETHAN exprNum: e1          {: if ( e > e1) RESULT = true; 										
																else RESULT = false;		 	  :} 
	            | exprNum:e ISEQUAL exprNum: e1          {: if ( e == e1) RESULT = true; 										
																else RESULT = false;		 	  :} 
          		;     	